# Payment Service

## Что было сделано

1. Реализованы API по требованию:
   - Добавление пользователя
   - Добавление транзакции (DEPOSIT/WITHDRAW)
   - Получение информации о транзакции
   - Получение текущего баланса пользователя и баланса на определенную дату

2. Покрыты интеграционными тестами:
   - Все API-методы имеют интеграционные тесты
   - Тесты используют отдельную тестовую БД
   - Обеспечена изоляция тестов и очистка данных

3. Для хранения баланса используется архитектура на основе транзакций:
   - Фиксируем изменения в таблице Transactions
   - Рассчитываем баланс на основе истории транзакций и храним в таблице **BalanceHistory**
   - Гарантируем неотрицательный баланс пользователя

## ДОПОЛНИТЕЛЬНЫЕ ТРЕБОВАНИЯ

### 1. Гарантия неотрицательного баланса

- Реализована проверка достаточности средств перед операцией WITHDRAW
- Добавлена обработка ошибки 409 Conflict при недостаточном балансе
- Обеспечена атомарность операций через транзакции в БД

### 2. Обработка транзакции ровно 1 раз (exactly-once)

- **Идемпотентность API**: реализована полная идемпотентность API через механизм проверки существования транзакций
- **Уникальный идентификатор (uid)**: каждая транзакция имеет уникальный идентификатор, который проверяется перед обработкой
- **Двухэтапная проверка**: сначала проверяем наличие транзакции, затем повторно проверяем в случае гонки условий
- **Обработка повторных запросов**: при повторном запросе с тем же uid возвращается существующая транзакция без повторного выполнения
- **Защита от дублирования**: даже при многократных запросах баланс изменяется только один раз
- **Транзакционная обработка**: все операции с базой данных выполняются в рамках транзакций для обеспечения атомарности
- **Тестовое покрытие**: добавлены тесты, подтверждающие правильную работу идемпотентности

### 3. Уведомление других сервисов

Я бы предложил следующий подход для уведомления других сервисов:

- **Outbox Pattern**: использовать паттерн Outbox для надежной доставки событий
  - Записывать события в транзакционную таблицу вместе с основными данными
  - Отдельный процесс читает события и отправляет во внешнюю систему

- **И представим интеграцию с каким ниубдь условным рекламным движком**:
  - Публиковать события при изменении баланса
  - Рекламный движок подписывается на эти события
  - Активация рекламы при достижении определенного порога баланса

### 4. Запуск в Kubernetes

Для запуска в Kubernetes я бы предложил:
- Создание Deployment, Service, ConfigMap манифестов
- Настройка liveness/readiness проб
- Конфигурация ресурсов и масштабирования
- Стратегия обновления RollingUpdate

### 5. Инструменты контроля качества

Для полноценного контроля качества я бы предложил применить:

1. **Мониторинг**:
   - Prometheus + Grafana для сбора и отображения метрик
   - Метрики: latency, error rate, throughput, database connections

2**Логирование**:
   - ELK стек для централизованного сбора и анализа логов
   - Структурированные JSON-логи с correlation ID

3**Тестирование**:
   - Unit-тесты для бизнес-логики
   - Интеграционные тесты для API
   - Нагрузочное тестирование

## API Endpoints

### Users
- `POST /api/user/` - Создание пользователя
- `GET /api/user/{user_id}/balance/` - Получение баланса пользователя

### Transactions
- `PUT /api/transaction/` - Создание транзакции
- `POST /api/transaction/{transaction_id}` - Получение информации о транзакции

## Запуск

```bash
docker-compose up --build
```

## Тестирование

```bash
docker-compose exec application pytest tests/test_api.py -v
```

## Based on fastapi-sqlalchemy-template

https://github.com/mdhishaamakhtar/fastapi-sqlalchemy-postgres-template/

This is for test purposes only.


## Тестовое задание
Вы можете разместить его в открытом доступе на github или gitlab. Тестовое задание рассчитано максимум на 2 часа, весь вспомогательный код написан, нужно дописать только логику. Интервью будет назначено после тестового задания.

Сделать сервис по работе с балансами. Возьмите скелетон сервиса из архива.
Код предоставляется для сокращения затрат на boilerplate, его можно слегка переструктурировать и исправлять ошибки, если это уместно.

Нужно реализовать:

* REST API добавление пользователя
* REST API добавление транзакции (DEPOSIT или WITHDRAW)
* REST API получить информацию о транзакции
* REST API получить текущий баланс пользователя (без селекта всех транзакций) или баланс за дату (например, запрос "сколько у Васи было денег 5.05.2022 00:00")

Ваш код должен быть покрыт тестами.
Важно, чтобы тесты проверяли правильность работы программы, никаких требований к исполнению тестов нет. Код должен быть понятным, но требования к красоте нет.

* python3
* sqlalchemy
* postgresql

Дополнительно:
* учесть, что сервис будет запускаться в k8s.
* учесть, что архитектура должна гарантировать обработку транзакции ровно 1 раз. Какие требования это накладывает на сам сервис и соседние сервисы?
* описать (можно не реализовывать), как можно реализовать уведомление других сервисов о транзакциях. Например, уведомить рекламный движок, который работает при наличии средств на счету.
* тезисно перечислить, какие инструменты можно применить для контроля качества работы сервиса.
* гарантировать, что баланс пользователя не может быть отрицательным.

